
raindex-version: 8898591f3bcaa21dc91dc3b8584330fc405eadfa

gui:
  name: Two-sided dynamic spread strategies
  description: The dynamic spread strategy for market-making uses time-based adjustments to maintain liquidity by narrowing spreads as market conditions stabilize, while recalculating averages and trade sizes to mitigate risks during trends.
  deployments:
    - deployment: base-usdc-testcoin
      name: USDC<>TESTCOIN on Base.
      description: Rotate USDC and TESTCOIN on Base.

      fields:
        - binding: is-fast-exit
          name: Fast exit?
          description: If enabled, the strategy will attempt to exit any position it builds up in a single trade, as soon as it can do so profitably.
          presets:
            - name: Yes
              value: 1
            - name: No
              value: 0
        - binding: initial-io
          name: Initial price (USDC per TESTCOIN)
          description: The rough USDC price you see for TESTCOIN on Dex Screener (e.g. 0.04983).
          min: 0
        - binding: next-trade-multiplier
          name: Next trade multiplier
          description: This is the most the strategy will move the price in a single trade. Larger numbers will capture larger price jumps but trade less often, smaller numbers will trade more often but be less defensive against large price jumps in the market.
          min: 1
          presets:
            - name: 1.01x
              value: 1.01
            - name: 1.02x
              value: 1.02
            - name: 1.05x
              value: 1.05
        - binding: cost-basis-multiplier
          name: Cost basis multiplier
          description: The minimum spread applied to the breakeven in addition to the auction. This is applied in both directions so 1.01x would be a 2% total spread.
          min: 1
          presets:
            - name: 1 (auction spread only)
              value: 1
            - name: 1.0005x (0.1% total)
              value: 1.0005
            - name: 1.001x (0.2% total)
              value: 1.001
            - name: 1.0025x (0.5% total)
              value: 1.0025
            - name: 1.005x (1% total)
              value: 1.005
        - binding: time-per-epoch
          name: Time per halving (seconds)
          description: The amount of time (in seconds) between halvings of the price and the amount offered during each auction, relative to their baselines.
          min: 600
          presets:
            - name: 1 hour (3600)
              value: 3600
            - name: 2 hours (7200)
              value: 7200
            - name: 4 hours (14400)
              value: 14400
            - name: 8 hours (28800)
              value: 28800
        - binding: max-amount
          name: Max amount
          description: The maximum amount of USDC that will be offered in a single auction.
          min: 5
          presets:
            - name: $10
              value: 10
            - name: $20
              value: 20
            - name: $50
              value: 50
            - name: $100
              value: 100
        - binding: min-amount
          name: Minimum amount
          description: The minimum amount of USDC that will be offered in a single auction.
          min: 5
          presets:
            - name: $5
              value: 5
            - name: $10
              value: 10
            - name: $20
              value: 20
      deposits:
        - token: base-usdc
          min: 0
          presets:
            - 0
            - 100
            - 200
            - 500
            - 1000
        - token: base-testcoin
          min: 0
          presets:
            - 0
            - 1000
            - 5000
            - 10000
            - 20000

    - deployment: base-weth-testcoin
      name: WETH<>TESTCOIN on Base.
      description: Rotate WETH and TESTCOIN on Base.

      fields:
        - binding: is-fast-exit
          name: Fast exit?
          description: If enabled, the strategy will attempt to exit any position it builds up in a single trade, as soon as it can do so profitably.
          presets:
            - name: Yes
              value: 1
            - name: No
              value: 0
        - binding: initial-io
          name: Initial price (WETH per TESTCOIN)
          description: The rough WETH price you see for TESTCOIN on Dex Screener (e.g. 0.04983).
          min: 0
        - binding: next-trade-multiplier
          name: Next trade multiplier
          description: This is the most the strategy will move the price in a single trade. Larger numbers will capture larger price jumps but trade less often, smaller numbers will trade more often but be less defensive against large price jumps in the market.
          min: 1
          presets:
            - name: 1.01x
              value: 1.01
            - name: 1.02x
              value: 1.02
            - name: 1.05x
              value: 1.05
        - binding: cost-basis-multiplier
          name: Cost basis multiplier
          description: The minimum spread applied to the breakeven in addition to the auction. This is applied in both directions so 1.01x would be a 2% total spread.
          min: 1
          presets:
            - name: 1 (auction spread only)
              value: 1
            - name: 1.0005x (0.1% total)
              value: 1.0005
            - name: 1.001x (0.2% total)
              value: 1.001
            - name: 1.0025x (0.5% total)
              value: 1.0025
            - name: 1.005x (1% total)
              value: 1.005
        - binding: time-per-epoch
          name: Time per halving (seconds)
          description: The amount of time (in seconds) between halvings of the price and the amount offered during each auction, relative to their baselines.
          min: 600
          presets:
            - name: 1 hour (3600)
              value: 3600
            - name: 2 hours (7200)
              value: 7200
            - name: 4 hours (14400)
              value: 14400
            - name: 8 hours (28800)
              value: 28800
        - binding: max-amount
          name: Max amount
          description: The maximum amount of WETH that will be offered in a single auction.
          min: 0
          presets:
            - name: 0.1
              value: 0.1
            - name: 0.2
              value: 0.2
            - name: 0.5
              value: 0.5
            - name: 1
              value: 1
        - binding: min-amount
          name: Minimum amount
          description: The minimum amount of WETH that will be offered in a single auction.
          min: 0
          presets:
            - name: 0.1
              value: 0.1
            - name: 0.2
              value: 0.2
            - name: 0.5
              value: 0.5
            - name: 1
              value: 1
      deposits:
        - token: base-weth
          min: 0
          presets:
            - 0
            - 0.1
            - 0.2
            - 0.5
            - 1
        - token: base-testcoin
          min: 0
          presets:
            - 0
            - 1000
            - 5000
            - 10000
            - 20000

scenarios:
  base:
    orderbook: base
    runs: 1
    bindings:
      raindex-subparser: 0x662dFd6d5B6DF94E07A60954901D3001c24F856a
      history-cap: '1e50'
      shy-epoch: 0.05
    scenarios:
      usdc-testcoin:
        runs: 1
        bindings:
          amount-token: 0x833589fcd6edb6e08f4c7c32d4f71b54bda02913
          initial-output-token: 0x222789334D44bB5b2364939477E15A6c981Ca165
          initial-input-token: 0x833589fcd6edb6e08f4c7c32d4f71b54bda02913
      weth-testcoin:
        runs: 1
        bindings:
          amount-token: 0x4200000000000000000000000000000000000006
          initial-output-token: 0x222789334D44bB5b2364939477E15A6c981Ca165
          initial-input-token: 0x4200000000000000000000000000000000000006

networks:
  base:
    rpc: https://mainnet.base.org
    chain-id: 8453
    network-id: 8453
    currency: ETH

metaboards:
  base: https://api.goldsky.com/api/public/project_clv14x04y9kzi01saerx7bxpg/subgraphs/mb-base-0x59401C93/0.1/gn

subgraphs:
  base: https://example.com/subgraph

orderbooks:
  base:
    address: 0xd2938e7c9fe3597f78832ce780feb61945c377d7
    network: base
    subgraph: base

deployers:
  base:
    address: 0xC1A14cE2fd58A3A2f99deCb8eDd866204eE07f8D
    network: base

tokens:
  base-testcoin:
    network: base
    address: 0x222789334D44bB5b2364939477E15A6c981Ca165
    decimals: 18
  base-usdc:
    network: base
    address: 0x833589fcd6edb6e08f4c7c32d4f71b54bda02913
    decimals: 6
  base-weth:
    network: base
    address: 0x4200000000000000000000000000000000000006
    decimals: 18
 
orders:
  base-weth-testcoin:
    network: base
    orderbook: base
    inputs:
      - token: base-weth
      - token: base-testcoin
    outputs:
      - token: base-weth
      - token: base-testcoin
  base-usdc-testcoin:
    network: base
    orderbook: base
    inputs:
      - token: base-usdc
      - token: base-testcoin
    outputs:
      - token: base-usdc
      - token: base-testcoin

deployments:
  base-usdc-testcoin:
    order: base-usdc-testcoin
    scenario: base.usdc-testcoin
  base-weth-testcoin:
    order: base-weth-testcoin
    scenario: base.weth-testcoin

---
#raindex-subparser !Subparser for the Raindex.

#min-amount !Amount will decay down to this number each epoch.
#max-amount !Amount will decay down from this number each epoch.
#time-per-epoch !Duration of one unit of streaming amount and io ratio halflife.
#shy-epoch !Epoch below which only the minimum amount is offered.
#next-trade-multiplier !Start next auction at this x the last trade.
#history-cap !The max amount of trade history kept for cost basis tracking (denominated in same token as tranche size).
#amount-token !The token that is the amount token for the strategy. This denominates tranche sizes.
#initial-io !The IO ratio that the strategy starts at. The quote token is the output so that the IO ratio looks like a CEX price.
#initial-output-token !Initial output token for the initial IO ratio.
#initial-input-token !Initial input token for the initial IO ratio.
#cost-basis-multiplier !Multiplier for the cost basis IO ratio. Effectively a minimum spread.

#is-fast-exit !Non-zero for fast exit behaviour.

#last-trade-io-key "last-trade-io"
#last-trade-time-key "last-trade-time"
#last-trade-output-token-key "last-trade-output-token"
#vwaio-key "cost-basis-io-ratio"

#amount-is-output
  _: equal-to(amount-token output-token());

#get-cost-basis-io-ratio
  this-total-out-key: hash(order-hash() input-token() output-token()),
  this-vwaio-key: hash(this-total-out-key vwaio-key),
  other-total-out-key: hash(order-hash() output-token() input-token()),
  other-vwaio-key: hash(other-total-out-key vwaio-key),

  this-total-out: get(this-total-out-key),
  other-total-out: get(other-total-out-key),

  this-vwaio: get(this-vwaio-key),
  other-vwaio: get(other-vwaio-key);

#set-cost-basis-io-ratio
  /* first reduce outstanding inventory */
  this-total-out-key
  this-vwaio-key
  other-total-out-key
  other-vwaio-key
  this-total-out
  other-total-out
  this-vwaio
  other-vwaio: call<'get-cost-basis-io-ratio>(),

  other-reduction-out: min(other-total-out input-vault-increase()),
  reduced-other-total-out: sub(other-total-out other-reduction-out),

  :set(other-total-out-key reduced-other-total-out),
  :set(other-vwaio-key every(reduced-other-total-out other-vwaio)),

  /* then increase our inventory */
  this-total-in: mul(this-total-out this-vwaio),
  this-remaining-in: sub(input-vault-increase() other-reduction-out),
  this-new-in: add(this-total-in this-remaining-in),
  this-remaining-out: div(this-remaining-in calculated-io-ratio()),
  this-new-out: add(this-total-out this-remaining-out),
  this-new-vwaio: every(this-new-out div(this-new-in any(this-new-out max-value()))),
  cap-out: if(call<'amount-is-output>() history-cap div(history-cap any(this-new-vwaio calculated-io-ratio()))),
  capped-out: min(this-new-out cap-out),

  :set(this-total-out-key capped-out),
  :set(this-vwaio-key this-new-vwaio);

#halflife
epoch:,
/**
 * Shrinking the multiplier like this
 * then applying it 10 times allows for
 * better precision when max-io-ratio
 * is very large, e.g. ~1e10 or ~1e20+
 *
 * This works because `power` loses
 * precision on base `0.5` when the
 * exponent is large and can even go
 * to `0` while the io-ratio is still
 * large. Better to keep the multiplier
 * higher precision and drop the io-ratio
 * smoothly for as long as we can.
 */
multiplier:
  power(0.5 div(epoch 10)),
val:
  mul(
    multiplier
    multiplier
    multiplier
    multiplier
    multiplier
    multiplier
    multiplier
    multiplier
    multiplier
    multiplier
  );

#set-last-trade
last-io:,
:set(hash(order-hash() last-trade-time-key) now()),
:set(hash(order-hash() last-trade-io-key) last-io),
:set(hash(order-hash() last-trade-output-token-key) output-token());

#handle-add-order
using-words-from raindex-subparser
:set(hash(order-hash() last-trade-time-key) now()),
:set(hash(order-hash() last-trade-io-key) initial-io),
:set(hash(order-hash() last-trade-output-token-key) initial-output-token),
this-total-out-key: hash(order-hash() initial-input-token initial-output-token),
:set(this-total-out-key 1e-18),
:set(hash(this-total-out-key vwaio-key) initial-io);

#get-last-trade
stored-last-io:get(hash(order-hash() last-trade-io-key)),
stored-last-output-token:get(hash(order-hash() last-trade-output-token-key)),
last-time:get(hash(order-hash() last-trade-time-key)),
_: if(equal-to(stored-last-output-token output-token()) stored-last-io inv(stored-last-io));

#get-epoch
last-time _: call<'get-last-trade>(),
duration: sub(now() last-time),
epochs: div(duration time-per-epoch);

#amount-for-epoch
epoch io:,
decay: call<'halflife>(epoch),
shy-decay: every(greater-than(epoch shy-epoch) decay),
variable-component: sub(max-amount min-amount),
base-amount: add(min-amount mul(variable-component shy-decay)),
_: if(call<'amount-is-output>() base-amount mul(base-amount inv(io)));

#io-for-epoch
epoch:,
last-io: call<'get-last-trade>(),
this-vwaio
other-vwaio: call<'get-cost-basis-io-ratio>(),
cost-basis-io: mul(any(this-vwaio inv(any(other-vwaio max-value()))) cost-basis-multiplier),
max-next-trade: mul(max(cost-basis-io last-io) next-trade-multiplier),
baseline: any(cost-basis-io last-io),
variable-component: sub(max-next-trade baseline),
decay: call<'halflife>(epoch),
above-baseline: mul(variable-component decay),
_: add(baseline above-baseline);

#calculate-io
using-words-from raindex-subparser
epoch:call<'get-epoch>(),
io: call<'io-for-epoch>(epoch),
epoch-max-output: call<'amount-for-epoch>(epoch io),
other-total-out
_
other-vwaio: call<'get-cost-basis-io-ratio>(),
max-output: max(
  epoch-max-output
  every(
    is-fast-exit
    mul(other-total-out other-vwaio))),
_: io,
:call<'set-last-trade>(io);

#handle-io
min-trade-amount: mul(min-amount 0.9),
:ensure(
  greater-than-or-equal-to(
    if(call<'amount-is-output>() output-vault-decrease() input-vault-increase())
    min-trade-amount)
  "Min trade amount."),
:call<'set-cost-basis-io-ratio>();